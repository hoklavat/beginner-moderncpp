*** MODERN CPP ***

[BASIC TERMS]
* Comment: used as notes by humans that read source code. ignored by compiler.
* Keyword: reserved keywords those are not available for redefinition or overloading.
* Escape Sequence: used to represent certain special characters within string literals and character literals.
* Preprocessor: preprocessing directives control the behavior of preprocessor that is executed at translation phase 4.
* Header: included source file into current source file.
* Identifier: used to name entities. unqualified, qualified.
* Name: denotes entity is introduced into program by declaration. identifier, overloaded operator, user defined conversion function, user defined literal, template name.
* Type: restricts operations that are permitted for specific entities and provides semantic meaning otherwise generic sequences of bits.
* Variable: declared objects and declared references that are not non-static data members.
* Pointer: points to object represents address of first byte in memory occupied by object.
* Reference: alias for object, is usually implemented to hold machine address of object. alternative name for object. lvalue/const/rvalue references.
* Scope: each name is valid in discontiguous portion of source code called its scope.
* Lifetime: for any object or reference there is point of execution of program when its lifetime begins and there is moment when it ends.
* Expression: sequence of operators and their operands that specifies computation.
* Full Expression: expression that is not subexpression of some other expression.
* Statement: fragments of program that are executed in sequence.
* Operator: defines type of operation between operands.
* Literal: tokens that represent constant values embedded in source code.
* Declaration: introduce names into program.
* Definition: declarations that fully define entity introduced by declaration.
* Initialization: provides initial value of variable at time of construction.
* Function: entities that associate sequence of statements with name and required parameters.
* Object: is region of storage that has size, alignment requirement, storage duration, lifetime, type, value, name.
* Class: user-defined type that can have data member, member function, nested types, enumerators, member templates.
* Template: entity that defines one of following: family of classes, family of functions, alias to family of types, family of variables, concept.
* Variadic Template: allows to handle arbitrary number of arbitrary types.
* Initializer List: allows to handle arbitrary number of arguments of single type.
* Exception: provides way of transferring control and information from some point in execution of program to handler.
* Module: help divide large amounts of code into logical parts.
* Name Lookup: procedure by which name, when encountered in a program, is associated with declaration that introduced it.
* As If Rule: allows any and all code transformations that do not change observable behavior of program.
* Undefined Behaviour: renders entire program meaningless if certain rules of language are violated.
* Memory Model: defines semantics of computer memory storage for purpose of abstract machine.
* Named Requirements: used in normative text of C++ standard to define expectations of standard library.
* Feature Testing: defines set of preprocessor macros those are intended as simple and portable way to detect presence of said features.
* Type Traits: defines compile-time template-based interface to query or modify properties of types.
* Concept: perform compile-time validation of template arguments and perform function dispatch based on properties of types.
* Container: generic collection of class templates and algorithms that allow programmers to easily implement common data structures.
* Iterator: specifies that objects of type can be incremented and dereferenced.
* Storage Duration: determines how storage for object is allocated and deallocated.
* Linkage: if name has linkage, it refers to same entity as same name introduced by declaration in another scope.
* Alignment: bytes used to hold object must have proper alignment for hardware to access it efficiently.
* Block: block is section of code delimited by {} pair.
* Implementation Defined: each implementation must provide specific, well-defined behavior for construct and that behavior must be documented.
* Prefix: affix which is placed before stem of word.
* Suffix: affix which is placed after stem of word.
* Has Identity: program has name of pointer or reference to object. (i)
* Movable: program allowed to move object value to another location and leave this object in valid but unspecified state. (m)
* LValue: expression that refers to object. something that can be on left-hand side of assignment. lvalue(i&!m) glvalue:generalized(i), xlvalue:extraordinary(i&m).
* RValue: value that is not lvalue. rvalue(m), prvalue:pure(!i&m)
* Dereferencing: referring to object pointed to by pointer. indirection.
* Null Pointer: pointer that does not point to an object. nullptr.
* Structure: aggregate of elements of arbitrary types.
* Const Correctness: prevent constant objects from getting mutated using const keyword.
* Plain Old Data: POD. contiguous sequence of bytes in memory. raw data. allows block operations.
* Trivial Type: type that has trivial default constructor, copy and move operations. trivial means no need to do work.
* Trivially Copyable Type: type that has nontrivial copy operation, move operation, or destructor. can be implemented as bitwise copy.
* Standard Layout Type:
* Union: struct in which all members are allocated at same address so that it occupies only as much space as its largest member.
* Enumeration: type that can hold set of integer values specified by user.
* Promotion: implicit conversion that preserve values. example: long to int.
* Narrowing Conversion: implicit conversion that can result information loss. example: int to long.
* Literal Type: class with constexpr constructor.
* Constant Expression: expression that compiler can evaluate.
* Handle: technique that will uniquely identify and get to another object.
* Encapsulation: preventing unauthorized access to some piece of information or functionality.
* Lexical Analysis: process of converting sequence of characters into sequence of tokens. takes modified source code from language preprocessors that are written in form of sentences. breaks these syntaxes into series of tokens, by removing any whitespace or comments in source code.
* Syntax Analysis: Parsing. set of rules, principles, and processes that govern structure of sentences in language. takes input from lexical analyzer in form of token streams and analyzes source code (token stream) against production rules to detect errors in code.
* Semantic Analysis: study of meaning. relationship between form and meaning. interpret symbols, their types, and their relations with each other. judges whether syntax structure constructed in source program derives any meaning or not.
* Constructor: builds objects from predefined types. explicit purpose is initializing objects.
* Default Constructor: constructor that can be called with no arguments, or that can take arguments, provided they are given default values.
* Named Constructor: provide public static methods that return object.
* RAII: Resource Acquisition Is Initialization. when object is constructed on free store, its pointer placed into manager object with destructor that will destroy it. this method avoids resource leaks and making error handling using exceptions simple and safe.
* Lambda Expression: simplified notation for defining and using anonymous function object. useful when passing operation as argument to algorithm. example: callback in gui applications.
* Casting: explicit type conversion.
* Inline Function: compiler attempts to generate code for a call of function inline rather than laying down code for function once and then calling through usual function call mechanism.
* One Definition Rule: ODR. there must be exactly one definition. definitions in different translation units must be identical.
* Overloading: using same name for operations on different types is called overloading.
* Friend: function or class that is allowed to access to another class or function.
* Static Typing: legality of member function invocation is checked at earliest possible moment by compiler at compile time. 
* Dynamic Binding: member function is selected dynamically (at run-time) based on type of object, not type of pointer/reference to that object.
* Pure Virtual Function: function that must be overridden in derived class and need not be defined.
* Abstract Class: no objects of class can be directly created. 
* Interface: class with no data and where all member functions are pure virtual functions.
* Argument Dependent Lookup: if function isn’t found in context of its use, it is looked in namespaces of its arguments.
* Translation Unit: unit is what compiler proper works on and what C++ language rules describe.
* Linker: loader. program that binds together separately compiled parts.
* External Linkage: name that can be used in translation units different from one in which it was defined. extern.
* Internal Linkage: name that can be referred to only in translation unit in which it is defined. not accessible from other source files. static.
* No Linkage: names that linker does not see, such as names of local variables.
* Virtual Table: data structure  for classes that have virtual functions to handle dynamic binding.
* Static Member: variable that is part of class, yet is not part of object of that class. there is only one copy for all objects.
* Concrete Class: representation is part of definition.
* Parameterized Type: type that is parameterized over another type or some value. class template or genericity.
* SFINAE: Substitution Failure Is Not An Error. if types do not match exactly in overloading resolution, conversions are not considered and template is simply dropped from set of viable functions.
* Precondition: condition that must always be true just prior to execution of code.
* Postcondition: condition that must always be true just after execution of code.
* Assertion: condition connected to point in program, that always should evaluate to true at that point in code execution.
* PIMPL: pointer to implementation.
* Rule of Five: if class has destructor that performs nontrivial task, such as free-store deallocation or lock release, class is likely to need full complement of functions: user-defined/copy/move constructors, copy/move assignments.
* STL: standard templates library. library that consists mainly of container classes, along with some iterators and algorithms to work with contents of these containers.
* Copy Constructor: makes copy of object without modifying it.
* Shallow Copy: copy and original objects can change their state. shared state.
* Invariant: invariant used for constraining objects of class.

[C++ ENTITIES]
* Type
* Value
* Reference
* Object
* Function
* Class Member
* Namespace
* Template
* Template Specialization
* Structured Binding
* Enumerator
* Parameter Pack

[FUNDAMENTAL TYPES]
* Boolean
* Character
* Integer
* Floating-Point
* Void

[USER DEFINED TYPES]
* Structure
* Enumeration
* Union
* Class

[TYPE CONVERSIONS]
* Function-Style: type(expression) (implicit type conversion.)
* Run-Time Checked: dynamic_cast<type>(expression) (run-time checked conversion of pointers and references into class hierarchy.)
* Compile-Time Checked: static_cast<type>(expression) (reversing well-defined implicit conversion. converts between related types such as one pointer type to another in same class hierarchy.)
* Unchecked: reinterpret_cast<type>(expression) (changing meaning of bit patterns. handles conversions between unrelated types such as integer to pointer.)
* Constant: const_cast<type>(expression) (getting write access to something declared const. converts between types that differ only in const and volatile qualifiers.)

[LEXICAL OPERATORS]
* Type Identification: typeid(type/expression)
* Size of Object/Type: sizeof(type/expression)
* Alignment: alignof(type)
* Heap Allocation: new
* Heap Deallocation: delete
* Throe Exception: throw
* Don't Throw Exception: noexcept

[TOKENS]
* Identifier
* Keyword
* Character Literal
* Integer Literal
* Floating-Point Literal
* String Literal ("...")
* Raw String Literal (R"...")
* Operator
* Punctuation
* Preprocessor Notation

[ALTERNATIVE LOGICAL OPERATORS]
* and (&&)
* and_eq (&=)
* bitand (&)
* bitor (|)
* compl (~)
* not (!)
* not_eq (!=)
* or (||)
* or_eq (|=)
* xor (^)
* xor_eq (^=)

[ESCAPE SEQUENCES]
* Simple Escape Sequences
   - \' - single quote
   - \" - double quote
   - \? - question mark
   - \\ - backslash
   - \a - audible bell
   - \b - backspace
   - \f - form feed
   - \n - line feed
   - \r - carriage return
   - \t - horizontal tab
   - \v - vertical tab
* Numeric Escape Sequences
   - \nnn - arbitrary octal value
   - \xnn - arbitrary hexadecimal value
* Conditional Escape Sequences
   - \c - Implementation-defined
* Universal Character Names
   - \unnnn - arbitrary Unicode value;
   - \Unnnnnnnn - arbitrary Unicode value;

[LITERALS]
-STRING-
* Raw String: R"(...)"
* UTF8 String: u8"..."
* UTF16 String: u"..."
* UTF32 String: U"..."

[CHARACTER TYPES]
* char
* signed char
* unsigned char
* wchar_t
* char16_t
* char32_t

[SCOPE of NAMES]
* Local: extends from point of declaration to end of block.
* Class: extends from opening { of class declaration to end of class declaration.
* Namespace: extends from point of declaration to end of its namespace.
* Global: extends from point of declaration to end of file in which its declaration occurs.
* Statement: extends from point of declaration defined within () to end of its statement.
* Function: extends from point of declaration until end of function.

[STATEMENTS]
* empty statement (;)
* block statement ({})
* declaration
* expression;
* {statement-list}
* try {statement-list} handler-list
* case constant-expression : statement
* default : statement
* break;
* continue;
* return expression;
* goto identifier;
* identifier : statement
* selection-statement
   - if(condition) statement
   - if(condition) statement else statement
   - switch(condition) statement
* iteration-statement
   - while(condition) statement
   - do statement while (expression);
   - for(for-init-statement condition; expression) statement
   - for(for-init-declaration : expression) statement
* statement-list:
   - statement statement-listopt
* condition:
   - expression
   - type-specifier declarator = expression
   - type-specifier declarator {expression}
* handler-list:
   - handler handler-list
* handler:
   - catch(exception-declaration){statement-list}

[NAMES]
* name is the use of one of the following to refer to an entity or to a label; 
   - identifier,
   - overloaded operator name in function notation,
   - user-defined conversion function name,
   - user-defined literal operator name,
   - template name followed by its argument list.

[LAMBDA EXPRESSIONS]
* Capture List: name specification.
   - []: empty capture list.
   - [&]: implicitly capture by reference.
   - [=]: implicitly capture by value.
   - [capture_list]: explicitly capture.
   - [&, capture_list]: implicitly capture by reference all local variables with names not mentioned in list.
   - [=, capture_list]: implicitly capture by value all local variables with names not mentioned in list.
* Parameter List: argument specification.
* mutable Specifier: body may modify state. default is const.
* noexcept Specifier: don't throw exception.
* Body: code specification.
* Return Type: ->

[FUNCTION SPECIFIERS]
* virtual: function can be overridden in derived class.
* override: function must be overriding virtual function from base class.
* final: function cannot be overriden in derived class.
* static: function is not associated with particular object.
* const: function may not modify its object.

[PREDEFINED MACROS]
* __cplusplus: defined in a C++ compilation and not in C compilation.
* __DATE__: date in ‘‘yyyy:mm:dd’’ format.
* __TIME__: time in ‘‘hh:mm:ss’’ format.
* __FILE__: name of current source file.
* __LINE__: source line number within current source file.
* __FUNC__: implementation-defined C-style string naming current function.
* __STDC_HOSTED__: 1 if implementation is hosted; otherwise 0.
* __STDC__: defined in C compilation and not in a C++ compilation.
* __STDC_MB_MIGHT_NEQ_WC__: 1 if in encoding for wchar_t, member of basic character set might have code value that differs from its value as ordinary character literal.
* __STDCPP_STRICT_POINTER_SAFETY__: 1 if implementation has strict pointer safety otherwise undefined.
* __STDCPP_THREADS__: 1 if program can have more than one thread of execution; otherwise undefined.

[PHASES OF TRANSLATION]

[STANDARD LIBRARY]

[LIFETIME]
* Automatic: created when its definition is encountered and destroyed when its name goes out of scope.
* Static: created and initialized once and lives until program terminates. static and automatic are storage classes.
* Free Store: objects whose lifetimes are controlled directly with new and delete operations.
* Temporary Objects: lifetime is determined their use. until reference lifetime or end of full expression.
* Thread Local Objects: created when their thread is start and destroyed when their thread is end.

[PROGRAM TERMINATION]
* return form main()
* calling exit()
* calling abort()
* throwing uncaught exception
* violating noexcept
* calling quick_exit()

[NOTES]
* prefer {} initialization over alternatives unless you have strong reason not to.
* prefer = when using auto rather than {} for initialization.
* size_t is implementation-defined unsigned integer type that can hold size in bytes of every object.
* for pointers, default value is nullptr.
* type deduction, auto (defined initializer), decltype (none defined initializer).
* lifetime of object starts when its constructor completes and ends when its destructor starts executing.
* lay out structure data members with larger members before smaller ones.
* operators && and || will not evaluate their second argument unless doing so is necessary.
* logical benefits of declaring variables in conditions, doing so also yields the most compact source code.
* don’t declare variable until you have value to initialize it with.
* for casting to boolean, nonzero value converts to true, zero value converts to false.
* reference can’t be separated from referent.
* if you don’t want to change object passed and it is big, call by const reference.
* order dependency: order of member objects in class body is critical. order of initializers in constructor initialization list is irrelevant.
* lambda’s return type is type of return’s expression.
* prefer prefix ++ over suffix ++.
* when explicit type conversion is necessary, prefer named cast.
* constant expression function consist of single return-statement; no branching, no loops and no local variables, no side effects are allowed. writing to nonlocal objects is not possible, but referring to them is allowed.
* if function cannot return, mark it [[noreturn]].
* static local variable allows function to preserve information between calls without introducing global variable that might be accessed and corrupted by other functions.
* use pass-by-const-reference to pass large values that you don’t need to modify.
* functions declared in different non-namespace scopes do not overload.
* don’t use macros unless you have to.
* function should perform single logical operation.
* if function may have to be evaluated at compile time, declare it constexpr.
* it is typically important that resources are released in reverse order of their acquisition.
* static members must be defined explicitly.
* Construct On First Use Idiom: object is constructed on its first use. uses pointer.
* it’s always portable and safe to change static data member into static member function.
* Named Parameter Idiom: change function’s parameters to methods of newly created class, where all these methods return *this by reference.
* explicit is optional keyword to tell compiler that certain constructor or conversion operator may not be used to implicitly cast expression to its class type.
* class destructor automatically invokes destructors for member objects.
* derived class destructor automatically invokes destructors for base class subobjects.
* self-assignment is not valid for move assignment.
* none overloadable operators are; .  ::  ?:  sizeof
* stack unwinding: process of passing the exception up stack from point of throw to handler.
* rethrow is indicated by throw without operand.
* constructor itself can catch sexceptions by enclosing complete function body,including member initializer list, in try-block.
* destructor should never throw exception.
* ++i is sometimes faster than, and is never slower than, i++.
* friend of friend isn’t necessarily friend.
* private: member/friend, protected: member/friend/derived, public: everyone.
* prefer compile-time checking to run-time checking.
* prefer standard library rather than implementing same function again.
* use span to prevent array decay and range errors.
* use narrow, narrow_cast for narrowing conversions.
* prefer templates instead of casting if possible.
* use variant rather than union.
* if pure virtual function is not overridden in derived class, derived class also becomes abstract.
* non-virtual member functions are resolved statically. (at compile time)
* virtual member functions are resolved dynamically. (at run-time)
* gsl::index should be used for indexing.
* when derived-class object is deleted via base-class pointer destructor should be virtual.
* if extern variable has been initialized, extern would simply be ignored because declaration with initializer is always definition.
* object must be defined exactly once in program.
* entity must be declared before it is used.
* unnamed namespace can be used to make names local to compilation unit. like internal linkage.
* use include guard to prevent compiler evaluate same code again.
* overload resolution conceptually happens in one scope at time.
* dreaded diamond refers to class structure in which particular class appears more than once in inheritance hierarchy. causes ambiguity.
* Virtual Inheritance: to avoid duplicated base class subobject that occurs with dreaded diamond, virtual keyword is used in inheritance part of classes that derive directly from top of diamond.
* by default, copy constructor and copy assignment of class object is copy of each member.
* struct is class in which members are by default public.
* prefer {} notation over () notation for constructor initialization.
* initialization with an = is considered copy initialization.
* declare constructor that can be called with single argument explicit.
* const does not apply (transitively) to objects accessed through pointers or references.
* nested class can refer to types and static members of its enclosing class, but has no notion of current object of enclosing class.
* Dynamic Binding During Initialization Idiom: calling virtuals during initialization.
* Don’t pass arrays as pointers, pass object representing range.
* Prefer struct as parameter type rather than long argument list.
* Prefer abstract classes as interfaces to class hierarchies.
* Separate interface of class from its implementation.
* Destructor will be implicitly invoked whenever X goes out of scope or is deleted.
* Destruction can be prevented by declaring destructor =delete or private.
* virtual destructor in base class makes it possible to delete appropriate derived class destructor.
* default constructor disappears when you define constructor requiring arguments. copy constructor does not disappear.
* references and consts must be initialized.
* you cannot both delegate and explicitly initialize member.
* using =default is always better than writing your own implementation of default semantics.
* copy operations should provide equivalence and independence.
* if class is used as base class, protect against slicing.
* make sure that copy assignments are safe for self-assignment.
* Nifty Counter Idiom: 
* Return Value Optimization: 

[ISO CPP GUIDELINESS]
P.1: Express ideas directly in code.
P.2: Write in ISO Standard C++.
P.3: Express intent.
P.4: Ideally, a program should be statically type safe.
P.5: Prefer compile-time checking to run-time checking.
P.6: What cannot be checked at compile time should be checkable at run time.
P.7: Catch run-time errors early.
P.8: Don’t leak any resources.
P.9: Don’t waste time or space.
P.10: Prefer immutable data to mutable data.
P.11: Encapsulate messy constructs, rather than spreading through the code.
P.12: Use supporting tools as appropriate.
P.13: Use support libraries as appropriate.
I.1: Make interfaces explicit.
I.2: Avoid non-const global variables.
I.3: Avoid singletons.
I.4: Make interfaces precisely and strongly typed.
I.5: State preconditions (if any).
I.6: Prefer Expects() for expressing preconditions.
I.7: State postconditions.
I.8: Prefer Ensures() for expressing postconditions.
I.9: If an interface is a template, document its parameters using concepts.
I.10: Use exceptions to signal a failure to perform a required task.
I.11: Never transfer ownership by a raw pointer (T*) or reference (T&).
I.12: Declare a pointer that must not be null as not_null.
I.13: Do not pass an array as a single pointer.
I.22: Avoid complex initialization of global objects.
I.23: Keep the number of function arguments low.
I.24: Avoid adjacent parameters of the same type when changing the argument order would change meaning.
I.25: Prefer abstract classes as interfaces to class hierarchies.
I.26: If you want a cross-compiler ABI, use a C-style subset.
I.27: For stable library ABI, consider the Pimpl idiom.
I.30: Encapsulate rule violations.
