*** MODERN CPP ***

[BASIC TERMS]
* Abstract Class: no objects of class can be directly created. 
* Alignment: bytes used to hold object must have proper alignment for hardware to access it efficiently. 
* Argument Dependent Lookup: if function isn’t found in context of its use, it is looked in namespaces of its arguments. 
* As If Rule: allows any and all code transformations that do not change observable behavior of program. 
* Assertion: condition connected to point in program, that always should evaluate to true at that point in code execution. 
* Block: block is section of code delimited by {} pair. 
* Casting: explicit type conversion. 
* Class: user-defined type that can have data member, member function, nested types, enumerators, member templates. 
* Comment: used as notes by humans that read source code. ignored by compiler. 
* Concept: perform compile-time validation of template arguments and perform function dispatch based on properties of types. 
* Concrete Class: representation is part of definition. 
* Const Correctness: prevent constant objects from getting mutated using const keyword. 
* Constant Expression: expression that compiler can evaluate. 
* Constructor: builds objects from predefined types. explicit purpose is initializing objects. 
* Container: generic collection of class templates and algorithms that allow programmers to easily implement common data structures. 
* Copy Constructor: makes copy of object without modifying it. 
* Declaration: introduce names into program. 
* Default Constructor: constructor that can be called with no arguments, or that can take arguments, provided they are given default values. 
* Definition: declarations that fully define entity introduced by declaration. 
* Dereferencing: referring to object pointed to by pointer. indirection. 
* Dynamic Binding: member function is selected dynamically (at run-time) based on type of object, not type of pointer/reference to that object. 
* Encapsulation: preventing unauthorized access to some piece of information or functionality. 
* Enumeration: type that can hold set of integer values specified by user. 
* Escape Sequence: used to represent certain special characters within string literals and character literals. 
* Exception: provides way of transferring control and information from some point in execution of program to handler. 
* Expression: sequence of operators and their operands that specifies computation. 
* External Linkage: name that can be used in translation units different from one in which it was defined. extern. 
* Feature Testing: defines set of preprocessor macros those are intended as simple and portable way to detect presence of said features. 
* Friend: function or class that is allowed to access to another class or function. 
* Full Expression: expression that is not subexpression of some other expression. 
* Function: entities that associate sequence of statements with name and required parameters. 
* Handle: technique that will uniquely identify and get to another object. 
* Has Identity: program has name of pointer or reference to object. (i) 
* Header: included source file into current source file. 
* Identifier: used to name entities. unqualified, qualified. 
* Implementation Defined: each implementation must provide specific, well-defined behavior for construct and that behavior must be documented. 
* Initialization: provides initial value of variable at time of construction. 
* Initializer List: allows to handle arbitrary number of arguments of single type. 
* Inline Function: compiler attempts to generate code for a call of function inline rather than laying down code for function once and then calling through usual function call mechanism. 
* Interface: class with no data and where all member functions are pure virtual functions. 
* Internal Linkage: name that can be referred to only in translation unit in which it is defined. not accessible from other source files. static. 
* Invariant: invariant used for constraining objects of class. 
* Iterator: specifies that objects of type can be incremented and dereferenced. 
* Keyword: reserved keywords those are not available for redefinition or overloading. 
* Lambda Expression: simplified notation for defining and using anonymous function object. useful when passing operation as argument to algorithm. example 
* Lexical Analysis: process of converting sequence of characters into sequence of tokens. takes modified source code from language preprocessors that are written in form of sentences. breaks these syntaxes into series of tokens, by removing any whitespace or comments in source code. 
* Lifetime: for any object or reference there is point of execution of program when its lifetime begins and there is moment when it ends. 
* Linkage: if name has linkage, it refers to same entity as same name introduced by declaration in another scope. 
* Linker: loader. program that binds together separately compiled parts. 
* Literal: tokens that represent constant values embedded in source code. 
* Literal Type: class with constexpr constructor. 
* LValue: expression that refers to object. something that can be on left-hand side of assignment. lvalue(i&!m) glvalue 
* Memory Model: defines semantics of computer memory storage for purpose of abstract machine. 
* Module: help divide large amounts of code into logical parts. 
* Movable: program allowed to move object value to another location and leave this object in valid but unspecified state. (m) 
* Name: denotes entity is introduced into program by declaration. identifier, overloaded operator, user defined conversion function, user defined literal, template name. 
* Name Lookup: procedure by which name, when encountered in a program, is associated with declaration that introduced it. 
* Named Constructor: provide public static methods that return object. 
* Named Requirements: used in normative text of C++ standard to define expectations of standard library. 
* Narrowing Conversion: implicit conversion that can result information loss. example 
* No Linkage: names that linker does not see, such as names of local variables. 
* Null Pointer: pointer that does not point to an object. nullptr. 
* Object: is region of storage that has size, alignment requirement, storage duration, lifetime, type, value, name. 
* One Definition Rule: ODR. there must be exactly one definition. definitions in different translation units must be identical. 
* Operator: defines type of operation between operands. 
* Overloading: using same name for operations on different types is called overloading. 
* Parameterized Type: type that is parameterized over another type or some value. class template or genericity. 
* PIMPL: pointer to implementation. 
* Plain Old Data: POD. contiguous sequence of bytes in memory. raw data. allows block operations. 
* Pointer: points to object represents address of first byte in memory occupied by object. 
* Postcondition: condition that must always be true just after execution of code. 
* Precondition: condition that must always be true just prior to execution of code. 
* Prefix: affix which is placed before stem of word. 
* Preprocessor: preprocessing directives control the behavior of preprocessor that is executed at translation phase 4. 
* Promotion: implicit conversion that preserve values. example 
* Pure Virtual Function: function that must be overridden in derived class and need not be defined. 
* RAII: Resource Acquisition Is Initialization. when object is constructed on free store, its pointer placed into manager object with destructor that will destroy it. this method avoids resource leaks and making error handling using exceptions simple and safe. 
* Reference: alias for object, is usually implemented to hold machine address of object. alternative name for object. lvalue/const/rvalue references. 
* Rule of Five: if class has destructor that performs nontrivial task, such as free-store deallocation or lock release, class is likely to need full complement of functions 
* RValue: value that is not lvalue. rvalue(m), prvalue 
* Scope: each name is valid in discontiguous portion of source code called its scope. 
* Semantic Analysis: study of meaning. relationship between form and meaning. interpret symbols, their types, and their relations with each other. judges whether syntax structure constructed in source program derives any meaning or not. 
* SFINAE: Substitution Failure Is Not An Error. if types do not match exactly in overloading resolution, conversions are not considered and template is simply dropped from set of viable functions. 
* Shallow Copy: copy and original objects can change their state. shared state. 
* Stack Unwinding: process of removing function entries from function call stack at run time. 
* Standard Layout Type:  
* Statement: fragments of program that are executed in sequence. 
* Static Member: variable that is part of class, yet is not part of object of that class. there is only one copy for all objects. 
* Static Typing: legality of member function invocation is checked at earliest possible moment by compiler at compile time. 
* STL: standard templates library. library that consists mainly of container classes, along with some iterators and algorithms to work with contents of these containers. 
* Storage Duration: determines how storage for object is allocated and deallocated. 
* Structure: aggregate of elements of arbitrary types. 
* Suffix: affix which is placed after stem of word. 
* Syntax Analysis: Parsing. set of rules, principles, and processes that govern structure of sentences in language. takes input from lexical analyzer in form of token streams and analyzes source code (token stream) against production rules to detect errors in code. 
* Template: entity that defines one of following 
* Translation Unit: unit is what compiler proper works on and what C++ language rules describe. 
* Trivial Type: type that has trivial default constructor, copy and move operations. trivial means no need to do work. 
* Trivially Copyable Type: type that has nontrivial copy operation, move operation, or destructor. can be implemented as bitwise copy. 
* Type: restricts operations that are permitted for specific entities and provides semantic meaning otherwise generic sequences of bits. 
* Type Traits: defines compile-time template-based interface to query or modify properties of types. 
* Undefined Behaviour: renders entire program meaningless if certain rules of language are violated. 
* Union: struct in which all members are allocated at same address so that it occupies only as much space as its largest member. 
* Variable: declared objects and declared references that are not non-static data members. 
* Variadic Template: allows to handle arbitrary number of arbitrary types. 
* Virtual Table: data structure for classes that have virtual functions to handle dynamic binding. 

[C++ ENTITIES]
* Type
* Value
* Reference
* Object
* Function
* Class Member
* Namespace
* Template
* Template Specialization
* Structured Binding
* Enumerator
* Parameter Pack

[FUNDAMENTAL TYPES]
* Boolean
* Character
* Integer
* Floating-Point
* Void

[USER DEFINED TYPES]
* Structure
* Enumeration
* Union
* Class

[TYPE CONVERSIONS]
* Function-Style: type(expression) (implicit type conversion.)
* Run-Time Checked: dynamic_cast<type>(expression) (run-time checked conversion of pointers and references into class hierarchy.)
* Compile-Time Checked: static_cast<type>(expression) (reversing well-defined implicit conversion. converts between related types such as one pointer type to another in same class hierarchy.)
* Unchecked: reinterpret_cast<type>(expression) (changing meaning of bit patterns. handles conversions between unrelated types such as integer to pointer.)
* Constant: const_cast<type>(expression) (getting write access to something declared const. converts between types that differ only in const and volatile qualifiers.)

[LEXICAL OPERATORS]
* Type Identification: typeid(type/expression)
* Size of Object/Type: sizeof(type/expression)
* Alignment: alignof(type)
* Heap Allocation: new
* Heap Deallocation: delete
* Throe Exception: throw
* Don't Throw Exception: noexcept

[TOKENS]
* Identifier
* Keyword
* Character Literal
* Integer Literal
* Floating-Point Literal
* String Literal ("...")
* Raw String Literal (R"...")
* Operator
* Punctuation
* Preprocessor Notation

[ALTERNATIVE LOGICAL OPERATORS]
* and (&&)
* and_eq (&=)
* bitand (&)
* bitor (|)
* compl (~)
* not (!)
* not_eq (!=)
* or (||)
* or_eq (|=)
* xor (^)
* xor_eq (^=)

[ESCAPE SEQUENCES]
* Simple Escape Sequences
   - \' - single quote
   - \" - double quote
   - \? - question mark
   - \\ - backslash
   - \a - audible bell
   - \b - backspace
   - \f - form feed
   - \n - line feed
   - \r - carriage return
   - \t - horizontal tab
   - \v - vertical tab
* Numeric Escape Sequences
   - \nnn - arbitrary octal value
   - \xnn - arbitrary hexadecimal value
* Conditional Escape Sequences
   - \c - Implementation-defined
* Universal Character Names
   - \unnnn - arbitrary Unicode value;
   - \Unnnnnnnn - arbitrary Unicode value;

[LITERALS]
-STRING-
* Raw String: R"(...)"
* UTF8 String: u8"..."
* UTF16 String: u"..."
* UTF32 String: U"..."

[CHARACTER TYPES]
* char
* signed char
* unsigned char
* wchar_t
* char16_t
* char32_t

[SCOPE of NAMES]
* Local: extends from point of declaration to end of block.
* Class: extends from opening { of class declaration to end of class declaration.
* Namespace: extends from point of declaration to end of its namespace.
* Global: extends from point of declaration to end of file in which its declaration occurs.
* Statement: extends from point of declaration defined within () to end of its statement.
* Function: extends from point of declaration until end of function.

[STATEMENTS]
* empty statement (;)
* block statement ({})
* declaration
* expression;
* {statement-list}
* try {statement-list} handler-list
* case constant-expression : statement
* default : statement
* break;
* continue;
* return expression;
* goto identifier;
* identifier : statement
* selection-statement
   - if(condition) statement
   - if(condition) statement else statement
   - switch(condition) statement
* iteration-statement
   - while(condition) statement
   - do statement while (expression);
   - for(for-init-statement condition; expression) statement
   - for(for-init-declaration : expression) statement
* statement-list:
   - statement statement-listopt
* condition:
   - expression
   - type-specifier declarator = expression
   - type-specifier declarator {expression}
* handler-list:
   - handler handler-list
* handler:
   - catch(exception-declaration){statement-list}

[NAMES]
* name is the use of one of the following to refer to an entity or to a label; 
   - identifier,
   - overloaded operator name in function notation,
   - user-defined conversion function name,
   - user-defined literal operator name,
   - template name followed by its argument list.

[LAMBDA EXPRESSIONS]
* Capture List: name specification.
   - []: empty capture list.
   - [&]: implicitly capture by reference.
   - [=]: implicitly capture by value.
   - [capture_list]: explicitly capture.
   - [&, capture_list]: implicitly capture by reference all local variables with names not mentioned in list.
   - [=, capture_list]: implicitly capture by value all local variables with names not mentioned in list.
* Parameter List: argument specification.
* mutable Specifier: body may modify state. default is const.
* noexcept Specifier: don't throw exception.
* Body: code specification.
* Return Type: ->

[FUNCTION SPECIFIERS]
* virtual: function can be overridden in derived class.
* override: function must be overriding virtual function from base class.
* final: function cannot be overriden in derived class.
* static: function is not associated with particular object.
* const: function may not modify its object.

[PREDEFINED MACROS]
* __cplusplus: defined in a C++ compilation and not in C compilation.
* __DATE__: date in ‘‘yyyy:mm:dd’’ format.
* __TIME__: time in ‘‘hh:mm:ss’’ format.
* __FILE__: name of current source file.
* __LINE__: source line number within current source file.
* __FUNC__: implementation-defined C-style string naming current function.
* __STDC_HOSTED__: 1 if implementation is hosted; otherwise 0.
* __STDC__: defined in C compilation and not in a C++ compilation.
* __STDC_MB_MIGHT_NEQ_WC__: 1 if in encoding for wchar_t, member of basic character set might have code value that differs from its value as ordinary character literal.
* __STDCPP_STRICT_POINTER_SAFETY__: 1 if implementation has strict pointer safety otherwise undefined.
* __STDCPP_THREADS__: 1 if program can have more than one thread of execution; otherwise undefined.

[PHASES OF TRANSLATION]


[LIFETIME]
* Automatic: created when its definition is encountered and destroyed when its name goes out of scope.
* Static: created and initialized once and lives until program terminates. static and automatic are storage classes.
* Free Store: objects whose lifetimes are controlled directly with new and delete operations.
* Temporary Objects: lifetime is determined their use. until reference lifetime or end of full expression.
* Thread Local Objects: created when their thread is start and destroyed when their thread is end.

[PROGRAM TERMINATION]
* return form main()
* calling exit()
* calling abort()
* throwing uncaught exception
* violating noexcept
* calling quick_exit()

[STANDARD LIBRARY]
* Concepts library
   - <concepts> Fundamental library concepts. (C++20)
* Coroutines library
   - <coroutine> Coroutine support library. (C++20)
* Utilities library
   - <cstdlib> General purpose utilities: program control, dynamic memory allocation, random numbers, sort and search.
   - <csignal> Functions and macro constants for signal management.
   - <csetjmp> Macro (and function) that saves (and jumps) to an execution context.
   - <cstdarg> Handling of variable length argument lists.
   - <typeinfo> Runtime type information utilities.
   - <typeindex> std::type_index. (C++11)
   - <type_traits> Compile-time type information. (C++11)
   - <bitset> std::bitset class template.
   - <functional> Function objects, Function invocations, Bind operations and Reference wrappers.
   - <utility> Various utility components.
   - <ctime> C-style time/date utilites.
   - <chrono> C++ time utilites. (C++11)
   - <cstddef> Standard macros and typedefs.
   - <initializer_list> std::initializer_list class template. (C++11)
   - <tuple> std::tuple class template. (C++11)
   - <any> std::any class. (C++17)
   - <optional> std::optional class template. (C++17)
   - <variant> std::variant class template. (C++17)
   - <compare> Three-way comparison operator support. (C++20)
   - <version> Supplies implementation-dependent library information. (C++20)
   - <source_location> Supplies means to obtain source code location. (C++20)
* Dynamic memory management
   - <new> Low-level memory management utilities.
   - <memory> High-level memory management utilities.
   - <scoped_allocator> Nested allocator class. (C++11)
   - <memory_resource> Polymorphic allocators and memory resources. (C++17)
* Numeric limits
   - <climits> Limits of integral types.
   - <cfloat> Limits of floating-point types.
   - <cstdint> Fixed-width integer types and limits of other types. (C++11)
   - <cinttypes> Formatting macros, intmax_t and uintmax_t math and conversions. (C++11)
   - <limits> Uniform way to query properties of arithmetic types.
* Error handling
   - <exception> Exception handling utilities.
   - <stdexcept> Standard exception objects.
   - <cassert> Conditionally compiled macro that compares its argument to zero.
   - <system_error> Defines std::error_code, a platform-dependent error code. (C++11)
   - <cerrno> Macro containing the last error number.
* Strings library
   - <cctype> Functions to determine the category of narrow characters.
   - <cwctype> Functions to determine the category of wide characters.
   - <cstring> Various narrow character string handling functions.
   - <cwchar> Various wide and multibyte string handling functions.
   - <cuchar> C-style Unicode character conversion functions. (C++11)
   - <string> std::basic_string class template.
   - <string_view> std::basic_string_view class template. (C++17)
   - <charconv> std::to_chars and std::from_chars. (C++17)
   - <format> Formatting library including std::format. (C++20)
* Containers library
   - <array> std::array container. (C++11)
   - <vector> std::vector container.
   - <deque> std::deque container.
   - <list> std::list container.
   - <forward_list> std::forward_list container. (C++11)
   - <set> std::set and std::multiset associative containers.
   - <map> std::map and std::multimap associative containers.
   - <unordered_set> std::unordered_set and std::unordered_multiset unordered associative containers. (C++11)
   - <unordered_map> std::unordered_map and std::unordered_multimap unordered associative containers. (C++11)
   - <stack> std::stack container adaptor.
   - <queue> std::queue and std::priority_queue container adaptors.
   - <span> std::span view. (C++20)
* Iterators library
   - <iterator> Range iterators.
* Ranges library
   - <ranges> Range access, primitives, requirements, utilities and adaptors. (C++20)
* Algorithms library
   - <algorithm> Algorithms that operate on ranges.
   - <execution> Predefined execution policies for parallel versions of the algorithms. (C++17)
* Numerics library
   - <cmath> Common mathematics functions.
   - <complex> Complex number type.
   - <valarray> Class for representing and manipulating arrays of values.
   - <random> Random number generators and distributions. (C++11)
   - <numeric> Numeric operations on values in ranges.
   - <ratio> Compile-time rational arithmetic. (C++11)
   - <cfenv> Floating-point environment access functions. (C++11)
   - <bit> Bit manipulation functions. (C++20)
   - <numbers>(C++20)Math constants.
* Localization library
   - <locale> Localization utilities.
   - <clocale> C localization utilities.
   - <codecvt> Unicode conversion facilities.(C++11, deprecated in C++17)
* Input/output library
   - <iosfwd> Forward declarations of all classes in the input/output library.
   - <ios> std::ios_base class, std::basic_ios class template and several typedefs.
   - <istream> std::basic_istream class template and several typedefs.
   - <ostream> std::basic_ostream, std::basic_iostream class templates and several typedefs.
   - <iostream> Several standard stream objects.
   - <fstream> std::basic_fstream, std::basic_ifstream, std::basic_ofstream class templates and several typedefs.
   - <sstream> std::basic_stringstream, std::basic_istringstream, std::basic_ostringstream class templates and several typedefs.
   - <syncstream> std::basic_osyncstream, std::basic_syncbuf, and typedefs. (C++20)
   - <strstream> std::strstream, std::istrstream, std::ostrstream. (deprecated in C++98)
   - <iomanip> Helper functions to control the format of input and output.
   - <streambuf> std::basic_streambuf class template.
   - <cstdio> C-style input-output functions.
* Filesystem library
   - <filesystem> std::path class and supporting functions. (C++17)
* Regular Expressions library
   - <regex> Classes, algorithms and iterators to support regular expression processing. (C++11)
* Atomic Operations library
   - <atomic> Atomic operations library. (C++11)
* Thread support library
   - <thread> std::thread class and supporting functions. (C++11)
   - <stop_token> Stop tokens for std::jthread. (C++20)
   - <mutex> Mutual exclusion primitives. (C++11)
   - <shared_mutex> Shared mutual exclusion primitives. (C++14)
   - <future> Primitives for asynchronous computations. (C++11)
   - <condition_variable> Thread waiting conditions. (C++11)
   - <semaphore> Semaphores. (C++20)
   - <latch> Latches. (C++20)
   - <barrier> Barriers. (C++20)

[NOTES]
* prefer {} initialization over alternatives unless you have strong reason not to.
* prefer = when using auto rather than {} for initialization.
* size_t is implementation-defined unsigned integer type that can hold size in bytes of every object.
* for pointers, default value is nullptr.
* type deduction, auto (defined initializer), decltype (none defined initializer).
* lifetime of object starts when its constructor completes and ends when its destructor starts executing.
* lay out structure data members with larger members before smaller ones.
* operators && and || will not evaluate their second argument unless doing so is necessary.
* logical benefits of declaring variables in conditions, doing so also yields the most compact source code.
* don’t declare variable until you have value to initialize it with.
* for casting to boolean, nonzero value converts to true, zero value converts to false.
* reference can’t be separated from referent.
* if you don’t want to change object passed and it is big, call by const reference.
* order dependency: order of member objects in class body is critical. order of initializers in constructor initialization list is irrelevant.
* lambda’s return type is type of return’s expression.
* prefer prefix ++ over suffix ++.
* when explicit type conversion is necessary, prefer named cast.
* constant expression function consist of single return-statement; no branching, no loops and no local variables, no side effects are allowed. writing to nonlocal objects is not possible, but referring to them is allowed.
* if function cannot return, mark it [[noreturn]].
* static local variable allows function to preserve information between calls without introducing global variable that might be accessed and corrupted by other functions.
* use pass-by-const-reference to pass large values that you don’t need to modify.
* functions declared in different non-namespace scopes do not overload.
* don’t use macros unless you have to.
* function should perform single logical operation.
* if function may have to be evaluated at compile time, declare it constexpr.
* it is typically important that resources are released in reverse order of their acquisition.
* static members must be defined explicitly.
* Construct On First Use Idiom: object is constructed on its first use. uses pointer.
* it’s always portable and safe to change static data member into static member function.
* Named Parameter Idiom: change function’s parameters to methods of newly created class, where all these methods return *this by reference.
* explicit is optional keyword to tell compiler that certain constructor or conversion operator may not be used to implicitly cast expression to its class type.
* class destructor automatically invokes destructors for member objects.
* derived class destructor automatically invokes destructors for base class subobjects.
* self-assignment is not valid for move assignment.
* none overloadable operators are; .  ::  ?:  sizeof
* stack unwinding: process of passing the exception up stack from point of throw to handler.
* rethrow is indicated by throw without operand.
* constructor itself can catch sexceptions by enclosing complete function body,including member initializer list, in try-block.
* destructor should never throw exception.
* ++i is sometimes faster than, and is never slower than, i++.
* friend of friend isn’t necessarily friend.
* private: member/friend, protected: member/friend/derived, public: everyone.
* prefer compile-time checking to run-time checking.
* prefer standard library rather than implementing same function again.
* use span to prevent array decay and range errors.
* use narrow, narrow_cast for narrowing conversions.
* prefer templates instead of casting if possible.
* use variant rather than union.
* if pure virtual function is not overridden in derived class, derived class also becomes abstract.
* non-virtual member functions are resolved statically. (at compile time)
* virtual member functions are resolved dynamically. (at run-time)
* gsl::index should be used for indexing.
* when derived-class object is deleted via base-class pointer destructor should be virtual.
* if extern variable has been initialized, extern would simply be ignored because declaration with initializer is always definition.
* object must be defined exactly once in program.
* entity must be declared before it is used.
* unnamed namespace can be used to make names local to compilation unit. like internal linkage.
* use include guard to prevent compiler evaluate same code again.
* overload resolution conceptually happens in one scope at time.
* dreaded diamond refers to class structure in which particular class appears more than once in inheritance hierarchy. causes ambiguity.
* Virtual Inheritance: to avoid duplicated base class subobject that occurs with dreaded diamond, virtual keyword is used in inheritance part of classes that derive directly from top of diamond.
* by default, copy constructor and copy assignment of class object is copy of each member.
* struct is class in which members are by default public.
* prefer {} notation over () notation for constructor initialization.
* initialization with an = is considered copy initialization.
* declare constructor that can be called with single argument explicit.
* const does not apply (transitively) to objects accessed through pointers or references.
* nested class can refer to types and static members of its enclosing class, but has no notion of current object of enclosing class.
* Dynamic Binding During Initialization Idiom: calling virtuals during initialization.
* Don’t pass arrays as pointers, pass object representing range.
* Prefer struct as parameter type rather than long argument list.
* Prefer abstract classes as interfaces to class hierarchies.
* Separate interface of class from its implementation.
* Destructor will be implicitly invoked whenever X goes out of scope or is deleted.
* Destruction can be prevented by declaring destructor =delete or private.
* virtual destructor in base class makes it possible to delete appropriate derived class destructor.
* default constructor disappears when you define constructor requiring arguments. copy constructor does not disappear.
* references and consts must be initialized.
* you cannot both delegate and explicitly initialize member.
* using =default is always better than writing your own implementation of default semantics.
* copy operations should provide equivalence and independence.
* if class is used as base class, protect against slicing.
* make sure that copy assignments are safe for self-assignment.
* you must never throw an exception from destructor.
* you can catch exception by value, by reference or by pointer.
* prefer member functions over nonmembers for operations that need access to representation.
* prefer nonmember functions over members for operations that do not need access to representation.

* Nifty Counter Idiom: 
* Return Value Optimization: 

[ISO CPP GUIDELINESS]
P.1: Express ideas directly in code.
P.2: Write in ISO Standard C++.
P.3: Express intent.
P.4: Ideally, a program should be statically type safe.
P.5: Prefer compile-time checking to run-time checking.
P.6: What cannot be checked at compile time should be checkable at run time.
P.7: Catch run-time errors early.
P.8: Don’t leak any resources.
P.9: Don’t waste time or space.
P.10: Prefer immutable data to mutable data.
P.11: Encapsulate messy constructs, rather than spreading through the code.
P.12: Use supporting tools as appropriate.
P.13: Use support libraries as appropriate.
I.1: Make interfaces explicit.
I.2: Avoid non-const global variables.
I.3: Avoid singletons.
I.4: Make interfaces precisely and strongly typed.
I.5: State preconditions (if any).
I.6: Prefer Expects() for expressing preconditions.
I.7: State postconditions.
I.8: Prefer Ensures() for expressing postconditions.
I.9: If an interface is a template, document its parameters using concepts.
I.10: Use exceptions to signal a failure to perform a required task.
I.11: Never transfer ownership by a raw pointer (T*) or reference (T&).
I.12: Declare a pointer that must not be null as not_null.
I.13: Do not pass an array as a single pointer.
I.22: Avoid complex initialization of global objects.
I.23: Keep the number of function arguments low.
I.24: Avoid adjacent parameters of the same type when changing the argument order would change meaning.
I.25: Prefer abstract classes as interfaces to class hierarchies.
I.26: If you want a cross-compiler ABI, use a C-style subset.
I.27: For stable library ABI, consider the Pimpl idiom.
I.30: Encapsulate rule violations.
F.1: “Package” meaningful operations as carefully named functions.
F.2: A function should perform a single logical operation.
F.3: Keep functions short and simple.
F.4: If a function may have to be evaluated at compile time, declare it constexpr.
F.5: If a function is very small and time-critical, declare it inline.
F.6: If your function may not throw, declare it noexcept.
F.7: For general use, take T* or T& arguments rather than smart pointers.
F.8: Prefer pure functions.
F.9: Unused parameters should be unnamed.
F.15: Prefer simple and conventional ways of passing information.
F.16: For “in” parameters, pass cheaply-copied types by value and others by reference to const.
F.17: For “in-out” parameters, pass by reference to non-const.
F.18: For “will-move-from” parameters, pass by X&& and std::move the parameter.
F.19: For “forward” parameters, pass by TP&& and only std::forward the parameter.
F.20: For “out” output values, prefer return values to output parameters.
F.21: To return multiple “out” values, prefer returning a struct or tuple
F.60: Prefer T* over T& when “no argument” is a valid option.
F.22: Use T* or owner<T*> to designate a single object.
F.23: Use a not_null<T> to indicate that “null” is not a valid value.
F.24: Use a span<T> or a span_p<T> to designate a half-open sequence.
F.25: Use a zstring or a not_null<zstring> to designate a C-style string.
F.26: Use a unique_ptr<T> to transfer ownership where a pointer is needed.
F.27: Use a shared_ptr<T> to share ownership.
F.42: Return a T* to indicate a position (only).
F.43: Never (directly or indirectly) return a pointer or a reference to a local object.
F.44: Return a T& when copy is undesirable and “returning no object” isn’t needed.
F.45: Don’t return a T&&.
F.46: int is the return type for main().
F.47: Return T& from assignment operators.
F.48: Don’t return std::move(local).
F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function).
F.51: Where there is a choice, prefer default arguments over overloading.
F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms.
F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread.
F.54: If you capture this, capture all variables explicitly (no default capture).
F.55: Don’t use va_arg arguments.
C.1: Organize related data into structures (structs or classes).
C.2: Use class if the class has an invariant; use struct if the data members can vary independently.
C.3: Represent the distinction between an interface and an implementation using a class.
C.4: Make a function a member only if it needs direct access to the representation of a class.
C.5: Place helper functions in the same namespace as the class they support.
C.7: Don’t define a class or enum and declare a variable of its type in the same statement.
C.8: Use class rather than struct if any member is non-public.
C.9: Minimize exposure of members.
Enum.1: Prefer enumerations over macros.
Enum.2: Use enumerations to represent sets of related named constants.
Enum.3: Prefer enum classes over “plain” enums.
Enum.4: Define operations on enumerations for safe and simple use.
Enum.5: Don’t use ALL_CAPS for enumerators.
Enum.6: Avoid unnamed enumerations.
Enum.7: Specify the underlying type of an enumeration only when necessary.
Enum.8: Specify enumerator values only when necessary.
R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization).
R.2: In interfaces, use raw pointers to denote individual objects (only).
R.3: A raw pointer (a T*) is non-owning.
R.4: A raw reference (a T&) is non-owning.
R.5: Prefer scoped objects, don’t heap-allocate unnecessarily.
R.6: Avoid non-const global variables.
R.10: Avoid malloc() and free().
R.11: Avoid calling new and delete explicitly.
R.12: Immediately give the result of an explicit resource allocation to a manager object.
R.13: Perform at most one explicit resource allocation in a single expression statement.
R.14: Avoid [] parameters, prefer span.
R.15: Always overload matched allocation/deallocation pairs.
R.20: Use unique_ptr or shared_ptr to represent ownership.
R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership.
R.22: Use make_shared() to make shared_ptrs.
R.23: Use make_unique() to make unique_ptrs.
R.24: Use std::weak_ptr to break cycles of shared_ptrs.
R.30: Take smart pointers as parameters only to explicitly express lifetime semantics.
R.31: If you have non-std smart pointers, follow the basic pattern from std.
R.32: Take a unique_ptr<widget> parameter to express that a function assumes ownership of a widget.
R.33: Take a unique_ptr<widget>& parameter to express that a function reseats the widget.
R.34: Take a shared_ptr<widget> parameter to express that a function is part owner.
R.35: Take a shared_ptr<widget>& parameter to express that a function might reseat the shared pointer.
R.36: Take a const shared_ptr<widget>& parameter to express that it might retain a reference count to the object ???.
R.37: Do not pass a pointer or reference obtained from an aliased smart pointer.
ES.1: Prefer the standard library to other libraries and to “handcrafted code”.
ES.2: Prefer suitable abstractions to direct use of language features.
ES.5: Keep scopes small.
ES.6: Declare names in for-statement initializers and conditions to limit scope.
ES.7: Keep common and local names short, and keep uncommon and non-local names longer.
ES.8: Avoid similar-looking names.
ES.9: Avoid ALL_CAPS names.
ES.10: Declare one name (only) per declaration.
ES.11: Use auto to avoid redundant repetition of type names.
ES.12: Do not reuse names in nested scopes.
ES.20: Always initialize an object.
ES.21: Don’t introduce a variable (or constant) before you need to use it.
ES.22: Don’t declare a variable until you have a value to initialize it with.
ES.23: Prefer the {}-initializer syntax.
ES.24: Use a unique_ptr<T> to hold pointers.
ES.25: Declare an object const or constexpr unless you want to modify its value later on.
ES.26: Don’t use a variable for two unrelated purposes.
ES.27: Use std::array or stack_array for arrays on the stack.
ES.28: Use lambdas for complex initialization, especially of const variables.
ES.30: Don’t use macros for program text manipulation.
ES.31: Don’t use macros for constants or “functions”.
ES.32: Use ALL_CAPS for all macro names.
ES.33: If you must use macros, give them unique names.
ES.34: Don’t define a (C-style) variadic function.
ES.40: Avoid complicated expressions.
ES.41: If in doubt about operator precedence, parenthesize.
ES.42: Keep use of pointers simple and straightforward.
ES.43: Avoid expressions with undefined order of evaluation.
ES.44: Don’t depend on order of evaluation of function arguments.
ES.45: Avoid “magic constants”; use symbolic constants.
ES.46: Avoid narrowing conversions.
ES.47: Use nullptr rather than 0 or NULL.
ES.48: Avoid casts.
ES.49: If you must use a cast, use a named cast.
ES.50: Don’t cast away const.
ES.55: Avoid the need for range checking.
ES.56: Write std::move() only when you need to explicitly move an object to another scope.
ES.60: Avoid new and delete outside resource management functions.
ES.61: Delete arrays using delete[] and non-arrays using delete.
ES.62: Don’t compare pointers into different arrays.
ES.63: Don’t slice.
ES.64: Use the T{e}notation for construction.
ES.65: Don’t dereference an invalid pointer.
ES.70: Prefer a switch-statement to an if-statement when there is a choice.
ES.71: Prefer a range-for-statement to a for-statement when there is a choice.
ES.72: Prefer a for-statement to a while-statement when there is an obvious loop variable.
ES.73: Prefer a while-statement to a for-statement when there is no obvious loop variable.
ES.74: Prefer to declare a loop variable in the initializer part of a for-statement.
ES.75: Avoid do-statements.
ES.76: Avoid goto.
ES.77: Minimize the use of break and continue in loops.
ES.78: Don’t rely on implicit fallthrough in switch statements.
ES.79: Use default to handle common cases (only).
ES.84: Don’t try to declare a local variable with no name.
ES.85: Make empty statements visible.
ES.86: Avoid modifying loop control variables inside the body of raw for-loops.
ES.87: Don’t add redundant == or != to conditions.
ES.100: Don’t mix signed and unsigned arithmetic.
ES.101: Use unsigned types for bit manipulation.
ES.102: Use signed types for arithmetic.
ES.103: Don’t overflow.
ES.104: Don’t underflow.
ES.105: Don’t divide by zero.
ES.106: Don’t try to avoid negative values by using unsigned.
ES.107: Don’t use unsigned for subscripts, prefer gsl::index.