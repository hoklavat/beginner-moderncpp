*** MODERN CPP ***

[BASIC TERMS]
* Comment: used as notes by humans that read source code. ignored by compiler.
* Keyword: reserved keywords those are not available for redefinition or overloading.
* Escape Sequence: used to represent certain special characters within string literals and character literals.
* Preprocessor: preprocessing directives control the behavior of preprocessor that is executed at translation phase 4.
* Header: included source file into current source file.
* Identifier: used to name entities. unqualified, qualified.
* Name: denotes entity is introduced into program by declaration. identifier, overloaded operator, user defined conversion function, user defined literal, template name.
* Type: restricts operations that are permitted for specific entities and provides semantic meaning otherwise generic sequences of bits.
* Variable: declared objects and declared references that are not non-static data members.
* Pointer: points to object represents address of first byte in memory occupied by object.
* Reference: alias for object, is usually implemented to hold machine address of object. alternative name for object. lvalue/const/rvalue references.
* Scope: each name is valid in discontiguous portion of source code called its scope.
* Lifetime: for any object or reference there is point of execution of program when its lifetime begins and there is moment when it ends.
* Expression: sequence of operators and their operands that specifies computation.
* Full Expression: expression that is not subexpression of some other expression.
* Statement: fragments of program that are executed in sequence.
* Operator: defines type of operation between operands.
* Literal: tokens that represent constant values embedded in source code.
* Declaration: introduce names into program.
* Definition: declarations that fully define entity introduced by declaration.
* Initialization: provides initial value of variable at time of construction.
* Function: entities that associate sequence of statements with name and required parameters.
* Object: is region of storage that has size, alignment requirement, storage duration, lifetime, type, value, name.
* Class: user-defined type that can have data member, member function, nested types, enumerators, member templates.
* Template: entity that defines one of the following: family of classes, family of functions, alias to family of types, family of variables, concept.
* Variadic Template: allows to handle arbitrary number of arbitrary types.
* Initializer List: allows to handle arbitrary number of arguments of single type.
* Exception: provides way of transferring control and information from some point in execution of program to handler.
* Module: help divide large amounts of code into logical parts.
* Name Lookup: procedure by which name, when encountered in a program, is associated with declaration that introduced it.
* As If Rule: allows any and all code transformations that do not change observable behavior of program.
* Undefined Behaviour: renders entire program meaningless if certain rules of language are violated.
* Memory Model: defines semantics of computer memory storage for purpose of abstract machine.
* Named Requirements: used in normative text of C++ standard to define expectations of standard library.
* Feature Testing: defines set of preprocessor macros those are intended as simple and portable way to detect presence of said features.
* Type Traits: defines compile-time template-based interface to query or modify properties of types.
* Concept: perform compile-time validation of template arguments and perform function dispatch based on properties of types.
* Container: generic collection of class templates and algorithms that allow programmers to easily implement common data structures.
* Iterator: specifies that objects of type can be incremented and dereferenced.
* Storage Duration: determines how storage for object is allocated and deallocated.
* Linkage: if name has linkage, it refers to same entity as same name introduced by declaration in another scope.
* Alignment: bytes used to hold object must have proper alignment for hardware to access it efficiently.
* Block: block is section of code delimited by {} pair.
* Implementation Defined: each implementation must provide specific, well-defined behavior for construct and that behavior must be documented.
* Prefix: affix which is placed before stem of word.
* Suffix: affix which is placed after stem of word.
* Has Identity: program has name of pointer or reference to object. (i)
* Movable: program allowed to move object value to another location and leave this object in valid but unspecified state. (m)
* LValue: expression that refers to object. something that can be on left-hand side of assignment. lvalue(i&!m) glvalue:generalized(i), xlvalue:extraordinary(i&m).
* RValue: value that is not lvalue. rvalue(m), prvalue:pure(!i&m)
* Dereferencing: referring to object pointed to by pointer. indirection.
* Null Pointer: pointer that does not point to an object. nullptr.
* Structure: aggregate of elements of arbitrary types.
* Const Correctness: prevent constant objects from getting mutated using const keyword.
* Plain Old Data: POD. contiguous sequence of bytes in memory. raw data. allows block operations.
* Trivial Type: type that has trivial default constructor, copy and move operations. trivial means no need to do work.
* Trivially Copyable Type: type that has nontrivial copy operation, move operation, or destructor. can be implemented as bitwise copy.
* Standard Layout Type:
* Union: struct in which all members are allocated at same address so that it occupies only as much space as its largest member.
* Enumeration: type that can hold set of integer values specified by user.
* Promotion: implicit conversion that preserve values. example: long to int.
* Narrowing Conversion: implicit conversion that can result information loss. example: int to long.
* Literal Type: class with constexpr constructor.
* Constant Expression: expression that compiler can evaluate.
* Handle: technique that will uniquely identify and get to another object.
* Encapsulation: preventing unauthorized access to some piece of information or functionality.
* Lexical Analysis: process of converting sequence of characters into sequence of tokens. takes modified source code from language preprocessors that are written in form of sentences. breaks these syntaxes into series of tokens, by
 removing any whitespace or comments in source code.
* Syntax Analysis: Parsing. set of rules, principles, and processes that govern structure of sentences in language. takes input from lexical analyzer in form of token streams and analyzes source code (token stream) against production
 rules to detect errors in code.
* Semantic Analysis: study of meaning. relationship between form and meaning. interpret symbols, their types, and their relations with each other. judges whether syntax structure constructed in source program derives any meaning or not.
* Constructor: builds objects from predefined types.
* Default Constructor: constructor that can be called with no arguments, or that can take arguments, provided they are given default values.
* Named Constructor: provide public static methods that return object.
* RAII: Resource Acquisition Is Initialization. when object is constructed on free store, its pointer placed into manager object with destructor that will destroy it. 
this method avoids resource leaks and making error handling using exceptions simple and safe.
* Lambda Expression: simplified notation for defining and using anonymous function object. useful when passing operation as argument to algorithm. example: callback in gui applications.
* Casting: explicit type conversion.
* Inline Function: compiler attempts to generate code for a call of function inline rather than laying down code for function once and then calling through usual function call mechanism.
* One Definition Rule: ODR. definitions in different translation units must be identical.
* Overloading: using same name for operations on different types is called overloading.

[C++ ENTITIES]
* Type
* Value
* Reference
* Object
* Function
* Class Member
* Namespace
* Template
* Template Specialization
* Structured Binding
* Enumerator
* Parameter Pack

[FUNDAMENTAL TYPES]
* Boolean
* Character
* Integer
* Floating-Point
* Void

[USER DEFINED TYPES]
* Structure
* Enumeration
* Union
* Class

[TYPE CONVERSIONS]
* Function-Style: type(expression) (implicit type conversion.)
* Run-Time Checked: dynamic_cast<type>(expression) (run-time checked conversion of pointers and references into class hierarchy.)
* Compile-Time Checked: static_cast<type>(expression) (reversing well-defined implicit conversion. converts between related types such as one pointer type to another in same class hierarchy.)
* Unchecked: reinterpret_cast<type>(expression) (changing meaning of bit patterns. handles conversions between unrelated types such as integer to pointer.)
* Constant: const_cast<type>(expression) (getting write access to something declared const. converts between types that differ only in const and volatile qualifiers.)

[LEXICAL OPERATORS]
* Type Identification: typeid(type/expression)
* Size of Object/Type: sizeof(type/expression)
* Alignment: alignof(type)
* Heap Allocation: new
* Heap Deallocation: delete
* Throe Exception: throw
* Don't Throw Exception: noexcept

[TOKENS]
* Identifier
* Keyword
* Character Literal
* Integer Literal
* Floating-Point Literal
* String Literal ("...")
* Raw String Literal (R"...")
* Operator
* Punctuation
* Preprocessor Notation

[ALTERNATIVE LOGICAL OPERATORS]
* and (&&)
* and_eq (&=)
* bitand (&)
* bitor (|)
* compl (~)
* not (!)
* not_eq (!=)
* or (||)
* or_eq (|=)
* xor (^)
* xor_eq (^=)

[ESCAPE SEQUENCES]
* Simple Escape Sequences
   - \' - single quote
   - \" - double quote
   - \? - question mark
   - \\ - backslash
   - \a - audible bell
   - \b - backspace
   - \f - form feed
   - \n - line feed
   - \r - carriage return
   - \t - horizontal tab
   - \v - vertical tab
* Numeric Escape Sequences
   - \nnn - arbitrary octal value
   - \xnn - arbitrary hexadecimal value
* Conditional Escape Sequences
   - \c - Implementation-defined
* Universal Character Names
   - \unnnn - arbitrary Unicode value;
   - \Unnnnnnnn - arbitrary Unicode value;

[LITERALS]
-STRING-
* Raw String: R"(...)"
* UTF8 String: u8"..."
* UTF16 String: u"..."
* UTF32 String: U"..."

[CHARACTER TYPES]
* char
* signed char
* unsigned char
* wchar_t
* char16_t
* char32_t

[SCOPE of NAMES]
* Local: extends from point of declaration to end of block.
* Class: extends from opening { of class declaration to end of class declaration.
* Namespace: extends from point of declaration to end of its namespace.
* Global: extends from point of declaration to end of file in which its declaration occurs.
* Statement: extends from point of declaration defined within () to end of its statement.
* Function: extends from point of declaration until end of function.

[STATEMENTS]
* empty statement (;)
* block statement ({})
* declaration
* expression;
* {statement-list}
* try {statement-list} handler-list
* case constant-expression : statement
* default : statement
* break;
* continue;
* return expression;
* goto identifier;
* identifier : statement
* selection-statement
   - if(condition) statement
   - if(condition) statement else statement
   - switch(condition) statement
* iteration-statement
   - while(condition) statement
   - do statement while (expression);
   - for(for-init-statement condition; expression) statement
   - for(for-init-declaration : expression) statement
* statement-list:
   - statement statement-listopt
* condition:
   - expression
   - type-specifier declarator = expression
   - type-specifier declarator {expression}
* handler-list:
   - handler handler-list
* handler:
   - catch(exception-declaration){statement-list}

[NAMES]
* name is the use of one of the following to refer to an entity or to a label; 
   - identifier,
   - overloaded operator name in function notation,
   - user-defined conversion function name,
   - user-defined literal operator name,
   - template name followed by its argument list.

[LAMBDA EXPRESSIONS]
* Capture List: name specification.
   - []: empty capture list.
   - [&]: implicitly capture by reference.
   - [=]: implicitly capture by value.
   - [capture_list]: explicitly capture.
   - [&, capture_list]: implicitly capture by reference all local variables with names not mentioned in list.
   - [=, capture_list]: implicitly capture by value all local variables with names not mentioned in list.
* Parameter List: argument specification.
* mutable Specifier: body may modify state. default is const.
* noexcept Specifier: don't throw exception.
* Body: code specification.
* Return Type: ->

[FUNCTION SPECIFIERS]
* virtual: function can be overridden in derived class.
* override: function must be overriding virtual function from base class.
* final: function cannot be overriden in derived class.
* static: function is not associated with particular object.
* const: function may not modify its object.

[PREDEFINED MACROS]
* __cplusplus: defined in a C++ compilation and not in C compilation.
* __DATE__: date in ‘‘yyyy:mm:dd’’ format.
* __TIME__: time in ‘‘hh:mm:ss’’ format.
* __FILE__: name of current source file.
* __LINE__: source line number within current source file.
* __FUNC__: implementation-defined C-style string naming current function.
* __STDC_HOSTED__: 1 if implementation is hosted; otherwise 0.
* __STDC__: defined in C compilation and not in a C++ compilation.
* __STDC_MB_MIGHT_NEQ_WC__: 1 if in encoding for wchar_t, member of basic character set might have code value that differs from its value as ordinary character literal.
* __STDCPP_STRICT_POINTER_SAFETY__: 1 if implementation has strict pointer safety otherwise undefined.
* __STDCPP_THREADS__: 1 if program can have more than one thread of execution; otherwise undefined.

[PHASES OF TRANSLATION]

[STANDARD LIBRARY]

[LIFETIME]
* Automatic: created when its definition is encountered and destroyed when its name goes out of scope.
* Static: created and initialized once and lives until program terminates. static and automatic are storage classes.
* Free Store: objects whose lifetimes are controlled directly with new and delete operations.
* Temporary Objects: lifetime is determined their use. until reference lifetime or end of full expression.
* Thread Local Objects: created when their thread is start and destroyed when their thread is end.

[NOTES]
* prefer {} initialization over alternatives unless you have strong reason not to.
* prefer = when using auto rather than {} for initialization.
* size_t is implementation-defined unsigned integer type that can hold size in bytes of every object.
* for pointers, default value is nullptr.
* type deduction, auto (defined initializer), decltype (none defined initializer).
* lifetime of object starts when its constructor completes and ends when its destructor starts executing.
* lay out structure data members with larger members before smaller ones.
* operators && and || will not evaluate their second argument unless doing so is necessary.
* logical benefits of declaring variables in conditions, doing so also yields the most compact source code.
* don’t declare variable until you have value to initialize it with.
* for casting to boolean, nonzero value converts to true, zero value converts to false.
* reference can’t be separated from referent.
* if you don’t want to change object passed and it is big, call by const reference.
* order dependency: order of member objects in class body is critical. order of initializers in constructor initialization list is irrelevant.
* lambda’s return type is type of return’s expression.
* prefer prefix ++ over suffix ++.
* when explicit type conversion is necessary, prefer named cast.
* constant expression function consist of single return-statement; no branching, no loops and no local variables, no side effects are allowed. writing to nonlocal objects is not possible, but referring to them is allowed.
* if function cannot return, mark it [[noreturn]].
* static local variable allows function to preserve information between calls without introducing global variable that might be accessed and corrupted by other functions.
* use pass-by-const-reference to pass large values that you don’t need to modify.
* functions declared in different non-namespace scopes do not overload.
* don’t use macros unless you have to.
* function should perform single logical operation.
* if function may have to be evaluated at compile time, declare it constexpr.
* it is typically important that resources are released in reverse order of their acquisition.
* static members must be defined explicitly.
* Construct On First Use Idiom: object is constructed on its first use. uses pointer.
* Nifty Counter Idiom: 
* it’s always portable and safe to change static data member into static member function.
* Named Parameter Idiom: change function’s parameters to methods of newly created class, where all these methods return *this by reference.
* explicit is optional keyword to tell compiler that certain constructor or conversion operator may not be used to implicitly cast expression to its class type.
* class destructor automatically invokes destructors for member objects.
* derived class destructor automatically invokes destructors for base class subobjects.
* self-assignment is not valid for move assignment.